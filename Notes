						Java

https://beginnersbook.com/java-tutorial-for-beginners-with-examples/

https://www.journaldev.com/370/java-programming-interview-questions

///////////////
Requirement 
Scope in – Tshirt sizing (15 weeks MED, 10 Weeks SM)
Bain Storm with PO and PM
Backwards from Customer like reverse Engg
All Unknowns, risks and new tech will be Spikes
 
Design 
SLA, Testing, Fail/Pass, Validation, Multi Solutions
Final Design sign off from Stake Holders
Assigning UI, Backend and DB different engineers to look after 

Audit Mechanism
Execution

Scrum of Scrums
Project Plan Checking
Milestones
Demo’s
Stakeholder Meetings
Update Milestones
Feedback
Bug bash
UAT
Deployment Rollout 5% 20% 60%
RetroSpecct(lesson learnt)
Metrics

Functional Requirement
Trade Offs
Write from Scratch
Use Existing
Communicate
//////////////////////////////

--------------------------------------------------------------------------------------------------------------------------
JDK - JRE + other tools and compilers

JRE - JVM + compiled class and libraries // install if just to run program

JVM - Class file loader + Memory(stack, heap, methods, Native Methods stack, PC registers) + Executors
Loads code
Verifies code
Executes code
Provides runtime environment

--------------------------------------------------------------------------------------------------------------------------
Public static void main(String[] args){
			//logic
}

public static void main(String []args)  
public static void main(String args[])  
public static void main(String... args)  
public static void main(String[] lilly)  
static public void main(String[] args)

The core advantage of the static method is that there is no need to create an object to invoke the static method. 
The main() method is executed by the JVM, so it doesn't require creating an object to invoke the main() method.

//where the program starts, JDK searchs for main() and executes n It should have string array
--------------------------------------------------------------------------------------------------------------------------
    								Creating Objects
Object - is a bundle of data[state] and its behaviour[methods]
You can Create object inside class but, need to call objects method inside main/other methods only but you can use the objects varailble value at class level.

Create objects
new           - Keyword obj = new Keyword();
newInstance() - NewInstanceMethod obj =(NewInstanceMethod) cls.newInstance();/ NewInstanceMethod obj = constructor.newInstance();
clone()       - CloneMethod obj2 = (CloneMethod) obj1.clone();
serialization - FileOutputStream fileOut = new FileOutputStream("/tmp/employee.ser");
factory method - Design Pattern

		OBJECT CLASS

Object class is the parent class of all the classes in java by default. In other words, it is the topmost class of java
It provides some common behaviors to all the objects such as object to compared, cloned, notified etc.

public final Class getClass()	     returns the Class of the obj and also used to get the metadata of this class.
public int hashCode()	          returns the hashcode number for this object.
public boolean equals(Object obj)	compares the given object to this object.
protected Object clone()       	creates and returns the exact copy (clone) of this object.
public String toString()	          returns the string representation of this object.
public final void notify()	     wakes up single thread, waiting on this object
public final void notifyAll()  	wakes up all the threads, waiting on this object
public final void wait()           current thread to wait for the specified milliseconds
protected void finalize()     	is invoked by the garbage collector before object is being garbage collected
--------------------------------------------------------------------------------------------------------------------------
							         CLONE()

object cloning is a way to create exact copy of an object. 
The java.lang.Cloneable interface must be implemented by the class whose object clone we want to create. 
If we don't implement Cloneable interface, clone() method generates CloneNotSupportedException.
    protected Object clone() throws CloneNotSupportedException {
    			Student18 s1 = new Student 18(101,"amit"); 
    			Student18 s2 = (Student18)s1.clone();      } 

dis adv - To use the Object.clone() method, we have changes in code, like 
implementing Cloneable interface, defining clone() method and handling CloneNotSupportedException, and finally, calling Object.clone() 

							  shallow and deep copy 
In shallow copy we create new objects that are exact copies of original object with reference address(i.e., memory address). 
In overridden clone method, if you are not cloning all the object types (not primitives), then you are making a shallow copy.
If you modify one object, the change will be reflected in the other object

In deep copy, it copies all fields, and makes copies of objects to which it refers(memory pointed)	

--------------------------------------------------------------------------------------------------------------------------
6 usage of java this keyword.

this() is used for calling the default constructor from parameterized constructor
this can be used to refer current class instance variable. - this.rollno=rollno; 
this can be used to invoke current class method (implicitly) - this.m(); 
this() can be used to invoke current class constructor - this(5);  
this can be passed as an argument in the method call -  m(this);  
this can be passed as argument in the constructor call - B b=new B(this);  
this can be used to return the current class instance from the method - return this;  

INSTANCE initializer block {//some logic at class level }
it is invoked after super() and at runs at method level

When a type of the object is determined at compiled time is known as STATIC binding. Dog d1=new Dog();  d1.eat();  
When a type of the object is determined at run-time is known as DYNAMIC binding.  Animal a=new Dog();    a.eat();  

instanceof - boolean - if object is an instance of class or subclass or interface, only way to downcast(errors otherwise)

 A class cannot be private or protected except nested class
 protected access modifier is accessible within package and outside the package but through inheritance only.
 default modifier is accessible only within package

--------------------------------------------------------------------------------------------------------------------------
						Data Types
Primitive - due to this data types java is not 100% obj oriented, we use wrapper class
int, double, char, boolean, long, float, byte, short

Non Primitive 
Arrays and Strings - allows all primitive, like array of integers, string of boolean etc,

camelCase
PascalCase
snake_case
kebab-case
--------------------------------------------------------------------------------------------------------------------------
									String
String is basically an object that represents sequence of char values. An array of characters works same as Java string
implements Serializable, Comparable and CharSequence interfaces

concat(), equals(), split(), length(), replace(), compareTo(), substring()

Java String is a powerful concept because everything is treated as a String if you submit any form in window based, web based or mobile application.

s.intern() - checks if string is available in Stringpool else creates new and returns

String(immutable), StringBuffer(mutable), StringBuilder(mutable) used to create strings in java

  String s=50+30+"Sachin"+40+40;  -> 80Sachin4040

String.join() method is available in Java version 8 and above->  String s = String.join("hello",s1,s2); -- s1hellos2
//StringTokenizer class allows you to break a String into tokens/ Strings [deprecated use split()]

StringBuffer class in Java is the same as String class except it is mutable. initial capacity is 16 later increse oldcapacity*2)+2
doesn't override the equals() method of Object class.
faster while performing concatenation operation then String and slower than StringBuilder
StringBuffer is synchronized, thread safe. It means two threads can't call the methods of StringBuffer simultaneously

StringBuilder is the most popular and fastet way to concatenate strings in Java
StringBuilder is non-synchronized ,not thread safe. It means two threads can call the methods of StringBuilder simultaneously.
StringBuilder is more efficient/faster than StringBuffer(introduced in Java 1.5)

Java String to Class object - Class.forName()

String pool (possible only because String is immutable in Java). String Constant Pool is an area inside the heap memory. it contains the unique strings, to put strings in the string pool, one needs to call the intern() method - new obj creates here, if same obj pointed to this existing memory else, if new obj, it will create new obj

String s1 = "Java";  									//it will store in the string pool    
String s2 = "Java";  									//it will store in the string pool    
String s3 = new String("Java");  						//store in Java heap  
String s4 = new String("Java").intern();  				//it will store in string pool  
System.out.println((s1 == s2)+", String are equal."); 		// true  
System.out.println((s1 == s3)+", String are not equal.");  // false  
System.out.println((s1 == s4)+", String are equal."); 	  // true, because reference variables are pointing to same instance 

--------------------------------------------------------------------------------------------------------------------------
						Wrapper Class
									
A Wrapper class is a class contains a primitive data types[toString(), int to INTEGER vice versa]. They convert primitive data types into objects. When we create an object to a wrapper class, it contains a field and in this field, we can store a primitive data types. 

conversion of primitive data type into its corresponding wrapper class is known as AUTOBOXING
conversion of wrapper type into its corresponding primitive type is known as UNBOXING
Since Java 5, we don't use explicitly valueOf()/ intValue() for convertion
--------------------------------------------------------------------------------------------------------------------------
								Static vs Final(Keywords)

The static member can be accessed before the class object is created. It share among all the objects of a class. when program runs, before the main method, static method loads and prints if there is a sysout 

Final keyword is used to declare - 
a variable which cannot modified, 
a method which cannot be overridden and 
a class that can not be inherited

a paramter inside a method
but you can still change its state (using setter methods e.g) or using append functions. 

not applicable for objects
can initialize blank final variable at only in constructor, likewise you can initialize in static block for static 

Final CLASS can't be inherited, final METHOD can't be overridden and final VARIABLE value can't be changed. 
Finally is used to place important code, it will be executed whether exception is handled or not. 
Finalize is used to perform clean up processing just before object is garbage collected.
--------------------------------------------------------------------------------------------------------------------------
					OOP(object oriented programming)

programming based on the concept of "objects",instead of just functions and procedures!
Object oriented programming brings together data and its behaviour(methods) in a single location(object) makes it easier to understand how a program works

-> Object - is a bundle of data,[state] and its behaviour(often known as methods)
Characteristics of Object - Abstraction, Encapsulation, Message passing

-> Class - user-defined blueprint from which objects are created.  It represents the set of properties or methods that are common to all objects of one type. In general, class declarations include Class name, Modifiers, Body if available Super Class and Interface. It cannot contain abstract methods

-> Constructor -if you do not have any constructor in your class, Java compiler inserts default constructor into your code on your behalf. Whenever a child class constructor gets invoked it implicitly invokes the constructor of parent class
super() is added in each class default constructor automatically by compiler if there is no super() or this() 

-> Interfaces -  blueprint of a class. Interface contains static constants and abstract methods. The interface in Java is a mechanism to achieve abstraction. There can be only abstract methods in the Java interface, not the method body. If a class implements an interface and does not provide method bodies for all functions specified in the interface, then class must be declared abstract.

4 PILLARS
-> Inheritance    
-> Encapsulation
-> Polymorphism   
-> Abstraction     

-> Assosiation(relation b/n 2classes) IS-A realation

-> Aggreagation 1:1(weak assosiation, HAS-A relation where methods survive without eachother, temporary) 

-> Composition(strong association, PART-OF relation, restrict form of aggregation, methods depend on each other, cannot exist without eachother, lifetime)
--------------------------------------------------------------------------------------------------------------------------
						Encapsulation (getter,setter)

"each object is private, inside a class. Other objects don’t have direct access but, they can access public functions(methods) but cannot change them". [get(),set(), seperate code, methods and communicate via method calling] 
 Java Bean class is the example of a fully encapsulated class// If you are creating class, you are doing encapsulation

It helps in binding methods and variables together. 
It provides data hiding. 
It helps in controlling the access using access modifiers.

ENCAPSULATION AND ABSTRACTION can help us in develop and maintain a huge codebase.
--------------------------------------------------------------------------------------------------------------------------
						  Inheritance (parent child) extends

The "child class reuses all fields and methods of the parent class (the common part) and can implement its own" (unique part).
Objects are often very similar while writing a code. They share common logic, But they’re not entirely the same!! 
by using inheritance, we can reuse the common logic and seperate unique logic into a separate class.

To reduce the complexity and simplify the language, multiple inheritance is not supported in java.

Inheritance should be used only if the relationship is-a is maintained throughout the lifetime of the objects involved; otherwise, aggregation is the best choice
--------------------------------------------------------------------------------------------------------------------------
							Polymorphism (over ride/load)

Ii is a way to use class exactly like its parent without any confusion with mixing types. But each child class have its own methods.
Parent class has bunch of methods. "child inherits parent class and implents it's own version of methods".

						Overloading - compile time/static polymorphism

Overloading occurs when two or more methods in one class have the SAME METHOD NAME but DIFFERENT PARAMETERS.
Method overloading is performed within class.
Type Promotion (int to long). Ambigity error if same parameters

								Overriding -Runtime/dynamic Polymorphism- On Inheritance
https://www.geeksforgeeks.org/overriding-in-java/

When a method in a subclass has the same name, same parameters or signature, and same return type(or sub-type) as a method in its super-class, then the method in the subclass is said to override the method in the super-class.
The version of a method that is executed will be determined by the object that is used to invoke it. If an object of a parent class is used to invoke the method, then the version in the parent class will be executed, but if an object of the subclass is used to invoke the method, then the version in the child class will be executed

Parent class reference points to the child class object then the call to the overridden method is determined at runtime, because during method call which method(parent class or child class) is to be executed is determined by the type of object, also called dynamic method dispatch

Static method cannot be overridden.
NO Same return type but, after java 5 CO-Variant (obj return type extends another)
Runtime polymorphism can't be achieved by data members- int num=10; in parent class used not from child class int num=20;
If you don't override the parent method, objects refer to child class of same method name 

Before Java5, it was not possible to override any method by changing the return type. But now, since Java5, it is possible to override method by changing the return type if subclass overrides any method whose return type is Non-Primitive but it changes its return type to subclass type
--------------------------------------------------------------------------------------------------------------------------
						Abstraction (only methods no logic)
Applying abstraction means that each "object should only expose a high-level mechanism and hide internal implementations".

A class which is declared with the abstract keyword is known as an abstract class 
A method that is declared but not defined. 
It has Only method signature no body
Abstract class (has abstract and non-abstract methods) but Interface only abstract methods
it is an natural extension of encapsulation.

EXAMPLE -> 
coffee machine makes lot of noises under the hood, you have to just put coffee and press a button without knowing how it works
--------------------------------------------------------------------------------------------------------------------------
							INTERFACE
interface in Java is a blueprint of a class, it has only static constants and abstract methods[empty body and fields are public, static and final]. 
A class that implements an interface must implement all the methods declared in the interface
An interface with exactly one abstract method is called Functional Interface

Since Java 8, we can have DEFAULT METHODS [default void msg(){}] and staic method[static int cube(int x){return x*x*x;}]
Since Java 9, we can have PRIVATE METHODS in an interface

It's used to achieve abstraction and multiple inheritance and loose coupling.
Interface fields are public, static and final by default[public static final int n=8;], and the methods are public and abstract[public abstract void method(){}] takes care by compiler

a class extends another class, an interface extends another interface, but a class implements an interface.
multiple inheritance is not supported in the case of class because of ambiguity, in case of an interface no ambiguity because its implementation is provided by the implementation class

An interface which has no member is known as a marker or tagged interface, for example, Serializable, Cloneable, Remote, etc
--------------------------------------------------------------------------------------------------------------------------
						abstract class vs interface ?

Abstraction class and Interface both of them are used for abstraction(shows only useful features & hides the internal implementation)

An "ABSTRACT CLASS(uses extends) used to create functionality that child classes can implement or override". 

An INTERFACE(uses implements) "has definition or signature of functionality but, cannot implement it". 

A class can extend only one abstract class but,it can take advantage of multiple interfaces.
-------------------------------------------------------------------------------------------------------------------------
								UpCasting

https://www.javatpoint.com/downcasting-with-instanceof-operator

If the reference variable of Parent class refers to the object of Child class, it is known as upcasting. 
class A{}  
class B extends A{
A a=new B();}//upcasting  

Upcasting is "casting a subtype to a supertype", upward to the inheritance tree. In general, we don't use upcasting unless if we want to write a code which deals only supertype.

DOWNCASTING is casting to a subtype, downward to the inheritance tree. Downcasting may fail if the actual object type is not the target object type by throwing a ClassCastException.

instanceof - is  way[ if(a instanceof Dog3){    Dog3 d=(Dog3)a;//downcasting  ] to downcast(errors otherwise)
Dog4 d=(Dog4)a;//downcasting  									
-------------------------------------------------------------------------------------------------------------------
						Comparator vs Comparable

Comparator interface compare(Object o1, Object o2) method need to be implemented that takes two Object argument, it should be implemented in such a way that it returns negative int if the first argument is less than the second one and returns zero if they are equal and positive int if the first argument is greater than the second one.

Comparable interface has compareTo(T obj) method which is used by sorting methods. We should override this method in such a way that it returns a negative integer, zero, or a positive integer if “this” object is less than, equal to, or greater than the object passed as an argument.	
==========================================================================================================================
							Serialization

Serialization is the process of "converting an object into a stream of bytes to store in a database", or a file. Its main purpose is to save the state of an object in order to be able to recreate it when needed. The reverse process is called deserialization.
											
						Serialize vs marshall
When you serialize an object, only the member data within that object is written to the byte stream; not the code that actually implements the object.

Marshalling is a process to transfer data between the RMI (Remote Method Invocation is an API for creating applications, for communicating b/n applications using two objects stub and skeleton). 

It's a process of converting the data or the objects into a byte-stream, and "unmarshalling" is the reverse process of converting the byte-stream beack to their original data or object using "serialization".
-------------------------------------------------------------------------------------------------------------------------
 						      TRY/ Catch
For each try block, there can be only 1 finally block.
finally block will not be executed if program exits by calling System.exit(); or by causing a fatal error that abort process
If an exception is not handled in the catch statement, before terminating the program, JVM executes the finally block
THROW  used to throw an exception explicitly
THROWS used to declare exceptions

 			  					Exceptions

Checked exceptions(class that inherits Throwable class) are checked at COMPILE time. file not found, input io 
Unchecked exceptions(class that inherits RuntimeException) are checked at RUN time. arithematic, out of bounds, npe 
Error is irrecoverable. Some example are OutOfMemoryError, VirtualMachineError, AssertionError etc.

Throws(method) clause is used to declare an exception- public int division(int a, int b) throws ArithmeticException
Throw keyword is used to throw an exception explicitly  -> throw new ArithmeticException("Arithmetic Exception");

ConcurrentModificationException - modify an element, before finishing the iteration

If the size is int or long and the results overflow the range of value, the methods addExact(), subtractExact(), multiplyExact(), and toIntExact() throw an ArithmeticException
--------------------------------------------------------------------------------------------------------------------------
								THREAD
A thread in Java at any point of time exists in any one of the following states. A thread lies only in one of the shown states at any instant:

New
Runnable
Blocked
Waiting
Timed Waiting
Terminated

A multi-threaded program allocates a fixed amount of time to each individual thread. Each and every thread runs for a short while and then pauses and relinquishes the CPU to another thread, so that other threads can get a chance to run. When this happens, all such threads that are ready to run, waiting for the CPU and the currently running thread lies in runnable state. It is the responsibility of the thread scheduler to give the thread, time to run.

								Two ways to create a THREAD:

1.By EXTENDING Thread class (provides constructors and methods to create and perform operations on a thread.Thread class extends Object class and implements Runnable interface)
We create a class that extends the java.lang.Thread class. This class overrides the run() method available in the Thread class
EX->

class Multi extends Thread{  

public void run(){  
     System.out.println("thread is running...");  
}  

public static void main(String args[]){  
		Multi t1 = new Multi();  
		t1.start();  
 }  }

Output:thread is running
-   -   -  -   -   -   -   
2.By IMPLEMENTING Runnable interface (should be implemented by any class whose instances are intended to be executed by a thread. Runnable interface have only one method named run()
EX->

class Multi implements Runnable{  

public void run(){  
	System.out.println("thread is running...");  
}  
  
public static void main(String args[]){  
	Multi m1 = new Multi();  
	Thread t1 = new Thread(m1);  
	t1.start();  
 }  }  

Thread Class vs Runnable Interface 

If we extend the Thread class, our class cannot extend any other class because Java doesn’t support multiple inheritance. But, if we implement the Runnable interface, our class can still extend other base classes.
We can achieve basic functionality of a thread by extending Thread class because it provides some inbuilt methods like yield(), interrupt() etc. that are not available in Runnable interface.
Using runnable will give you an object that can be shared amongst multiple threads. 

Always recommendable logically calling Thread.start() to start a new thread
thread.start()-> create a new thread(t0) and calls thread.run()
thread.run()-> thread method 

join() method allows one thread to wait until another thread completes its execution

 invoking start() method on a thread that has already started throws a IllegalThreadStateException because the thread is already in RUNNABLE state.

Thread Pool

samsung care + 18778411138
--------------------------------------------------------------------------------------------------------------------------
						Threadsafe

A class is thread-safe when it continues to "behaves/ executes correctly when accessed/executed from multiple threads at same time" 
all the basic collection classes - ArrayList, LinkedList, HashMap, HashSet, TreeMap, TreeSet, etc - all are not synchronized
In fact, all collection classes (except Vector and Hashtable) in the java.util package are not thread-safe

how to make thread safe 
-> Making object final
-> Making the object private - maintaining the same state for the object by returning at the same place
-> Synchronizing the objects
-> Concurrent Collections - dividing the data into segments/process, multiple threads can access the multiple segments at the same time.
--------------------------------------------------------------------------------------------------------------------------
							   Immutable(for OBJECTs, its Thread safe) 

			The "object’s value can’t be changed, but you can change its reference" to another one.
immutability applicable for an object, classes(if final, no setters, private fields) but not for variables.
Advantages of immutable?
  It decreases the overhead by garbage collection and it protect from code corrupting. 
We should prefer Classes should be immutable unless there's a very good reason to make them mutable or try to limit its mutability as much as possible.

All the datatypes are mutable except String(objects are cached in the String pool and accessed by multiple clients, for security and synchronization. stringbuilder to mute, safe for multithreading)
--------------------------------------------------------------------------------------------------------------------------
Data Structures

			ARRAY 
array is an object of a dynamically generated class. Java array inherits the Object class, and implements the Serializable as well as Cloneable interfaces. We can store primitive values or objects
arr.length;

         +							             -negatives
Storing(index based) 						size is fixed 
Random Access

If we clone single-dimensional array, it creates the deep copy of the Java array, means it will copy the actual value. 
if we clone multidimensional array, it creates the shallow copy of the Java array which means it copies the references.
Clone() is the fastest way to copy array.

--------------------------------------------------------------------------------------------------------------------------
                                           Collections

-> List store the ordered collection of objects. It can have DUPLICATE values. List interface is implemented by the classes ArrayList, LinkedList, Vector, and Stack.
----- ------ ----     ---------     -    - - - - - - - - - - - - - -- - 
-> ARRAY LIST (best for storing, retrieving) uses a dynamic array to store the duplicate element of different data types. The ArrayList class maintains the insertion order and is non-synchronized. The elements stored in the ArrayList class can be randomly accessed.

ArrayList<Integer> numbers = new ArrayList<Integer>();
      numbers.add(1);
      numbers.add(2,2);
      numbers.size();
   for(Integer i: numbers){}
   Collections.sort(numbers);	

Remove integer value from arrayList, use ->   remove(Integer.valueOf(77)); removes 77 value not index!

ensureCapacity()	setLength()	trimToSize()  // to resize the List with performance

Buffer capacity is set irrespective of length (number of characters). Buffer may be more than length,Extra buffer is deleted than required to store the characters

Iterator.hasnext();   iterator.next();//to get the values in the List

----- ------ ----     ---------     -    - - - - - - - - - - - - - -- - 
-> LINKED LIST (best for modification, insert, delete) uses a double linked list internally to store the elements. It can store the duplicate elements. It maintains the insertion order and is not synchronized. 
In LinkedList, the manipulation is fast because no shifting is required only the pointer of the previous and the next node requires change.

Memory allocation is done at the run time by the compiler

LinkedList<String> list=new LinkedList<String>();

     list.add("Steve");

     Iterator<String> iterator=list.iterator();
     while(iterator.hasNext()){}

----- ------ ----     ---------     -    - - - - - - - - - - - - - -- - 
Hashmap(best for seraching due to hashing) stores the data in Key, Value pairs(hashing and buckets). To access a value you must know its key. 
Hashing is a technique of converting a large String to small String that represents the same String. A shorter value helps in indexing and faster searches. 
In a HashMap the key is an object, that contains hashCode() and "equals(Object)" methods (to check already inserted or not)

1 null key and any null values

Map <int, String> hm = new Hashmap<int, String>();
	hm.put(1,"seven");
	for (Map.Entry me : hmap.entrySet()) {}    

	Iterator iterator = hmap.entrySet().iterator();  //you can replace with Set set = hmap.entrySet(); Iterator ite = set.iterator();
		While(iterator.hasnext()){}
		
	hm.getvalue(key);

	ListIterator<String> litr = hm.listIterator();
	while(litr.hasNext()){
	while(litr.hasPrevious()){    //iterate backward


					COLLLISION (only same indexes) different from replacing same value
distribute the values
Store in next bucket
Create a linked list at the index.

if you create (E,1) and update to (E,NULL) the hashmap wont allow GC to remove keys even if it has no reference 

Weakhashmap -works different and allow GC to collect unused objects

LinkedHashSet

if sync hashmap is existing why java 5 introduced concurrent hash map?
not thread safe, performance, due to lock every bucket while read/write 
read any threads but write lock on spe 


WRITE/ DRAW NOTES FOR COLLECTIONS AND UPLOAD
----- ------ ----     ---------     -    - - - - - - - - - - - - - -- - 

Set unordered set of elements which DOESNOT allow us to store the duplicate items. We can store at most one null value in Set. 
Set is implemented by HashSet, LinkedHashSet, and TreeSet.

Hashset uses a hash table for storage. Hashing is used to store the elements in the HashSet. It contains UNIQUE items.HashSet  uses HashMap internally.

Hashtable is synchronized. It is thread-safe and can be shared with many threads. doesn’t allow any null key or value.
----- ------ ----     ---------     -    - - - - - - - - - - - - - -- - 
Queue uses FIFO(First In First Out)

Stack used to store & delete LIFO(Last In First Out). push n pop methods.

flatMap() produces a stream of new values
map() it produces a single value
----- ------ ----     ---------     -    - - - - - - - - - - - - - -- - 
Vector uses a dynamic array to store the data elements. It is similar to ArrayList. However, it is synchronized and contains many methods that are not the part of Collection framework.
--------------------------------------------------------------------------------------------------------------------------
JAVA - SOLID RULES
DB  - ACID Properties													
								ACID Rules

Maintain consistency in a database, before and after transaction, we follow - ACID properties

Atomicity(A) - By this, we mean that either the entire transaction takes place at once or doesn’t happen at all. There is no midway i.e. transactions do not occur partially. Each transaction is considered as one unit and either runs to completion or is not executed at all. Atomicity is also known as the ‘All or nothing rule’.
It involves following two operations.
—Abort: If a transaction aborts, changes made to database are not visible.
—Commit: If a transaction commits, changes made are visible.

Consistency(C) − This represents the consistency of the referential integrity of the database, unique primary keys in tables, etc.

Isolation(I) − There may be many transaction processing with the same data set at the same time. Each transaction should be isolated from others to prevent data corruption.

Durability (D) − Once a transaction has completed, the results of this transaction have to be made permanent and cannot be erased from the database due to system failure.
--------------------------------------------------------------------------------------------------------------------------
  							SOLID rules while writing a program

Single Responsibility (class should have only one responsibility. Further, it should only have one reason to change)

Open/Closed (Open for Extension, Closed for Modification)

Liskov Substitution (if class A is subtype of class B,then we should replace B with A without creating any disturbances)

Interface Segregation (large interfaces r split into smaller ones. Classes r concerned about methods that interest to them)

Dependency Inversion (decoupling high-level modules depending on low-level modules. Now both will depend on abstractions)
--------------------------------------------------------------------------------------------------------------------------	
							Garbage collection

Mark and sweep technique - 
cycle 1 -marks used obj(increaase the age) and unused obj
cycle 2 -sweeps the unused obj

Heap - Young generation (hidden space- all the obj store here, if it's full minor GC called and marked unused obj and 
used obj moved to survivor 0
(hidden space, survivor 0 and survivor 1(from survivor0 and hidden space if used))

old gen(moved from young if used often), 
pom gen(moved here if old is full and major GC is called if pom gen is full) 

We cannot force garbage collection. It will only trigger if JVM thinks it needs a garbage collection based on Java heap size. other threads in the application have to be stopped to allow the garbage collector thread to effectively do its work. 
parent object is set to null
cleans Cyclic dependencies without any live external reference
finalize() Finalize is used to perform clean up processing just before object is garbage collected.

When Garbage Collector calls finalize() method on an object, it ignores all the exceptions raised in the method and program will terminate normally.

We know that finalize() method is called by Garbage Collector on an object before destroying it. But here, the trick is that the str is String class object, not the Test class. Therefore, finalize() method of String class(if overridden in String class) is called on str. If a class doesn’t override finalize method, then by default Object class finalize() method is called.

If finalize() method is already called for one object, Garbage Collector will destroy the same object if created again without calling finalize() method again
--------------------------------------------------------------------------------------------------------------------------
										STACK  VS HEAP MEMORY

stack memory is used to store local variables and function, 
Variables stored in stacks are only visible to the owner.
															heap memory is used to store objects in Java, visible to all threads.

Stack memory is used only by one thread of execution.	    Heap memory is used by all the parts of the application.
Stack memory can’t be accessed by other threads.	        Objects stored in the heap are globally accessible.
Fllows LIFO manner to free memory.	                        Memory management is based on the generation associated with each object.
Exists until the end of execution of the thread.	        Heap memory lives from the start till the end of application execution.
Stack memory only contains local primitive and reference 
variables to objects in heap space.	                         Whenever an object is created, it’s always stored in the Heap space
--------------------------------------------------------------------------------------------------------------------------
                              ****************JAVA 8 FEAUTURES**************

Streams(used for Operations on Collections)
intermediate(can modify after this like filter, map) or terminal methods(cant manipulate after like collect)

"FUNCTIONAL INTERFACES"  earlier there are no restrictions for abstract methods in interface, from java 8, they have restricted to have one abstract class and mulitple default static/default methods. used for reference to lamba expression
(EX-> eval(list, n-> n > 3); //printing no greater than 3). A functional interface is an interface that contains only one abstract method(one functionality to exhibit). 
EX -  Runnable, ActionListener, Comparable

LAMBDA EXPRESSIONS(Optionals, has body and parameter list)EX- MathOperation multiplication = (int a, int b) -> { return a * b; } )
->used to represent the instance of a functional interface

"METHOD REFERENCES" which help to point to methods by their names. 
 symbol - two colons :: (ex -> names.forEach(System.out::println)for printing all names in different lines)



NEW (simple)date-time API- using java.time for handling timezones, poor design like 0/1/1900, thread safe .

"Parallel Opearions" (sorting, filtering and mapping)

"MUTABILITY" java 8 feauturs are implemented in an immutable fashion 

"DEFAULT METHODS" (List/Collection interface can have a default implementation of FOREACH method, 
but, the class implementing these interfaces need not implement the same.)

"OPTIONAL" has not-null objects, handle values as ‘available’ or ‘not available’ instead of checking null values!
EX-> static <T> Optional<T> of(T value) -> it returns an Optional with the specified present non-null value.

"NASHORN" (we use jjs tool, to execute javascript codes at console), calling js from java using scriptEngineManager
EX -> jjs> print("Hello, World!")												
