

						https://beginnersbook.com/java-tutorial-for-beginners-with-examples/

--------------------------------------------------------------------------------------------------------------------------
JDK - JRE + other tools and comilers

JRE - JVM + compiled class and libraries

JVM - Class file loader + Memory(stack, heap, methods, Native Methods stack, PC registers) + Executors
Loads code
Verifies code
Executes code
Provides runtime environment

--------------------------------------------------------------------------------------------------------------------------
Public static void main(String[] args){
			//logic
}

public static void main(String []args)  
public static void main(String args[])  
public static void main(String... args)  
static public void main(String[] args)

The core advantage of the static method is that there is no need to create an object to invoke the static method. 
The main() method is executed by the JVM, so it doesn't require creating an object to invoke the main() method.

//where the program starts, JDK searchs for this main method and executes it. It should have string array and some name as it's designed when C, CPP used cmd line to execute.
We can also change the array name like - psvm(String[] name){}

We can also skip creating this array like psvm(String . . . anyname){}
//which might cause internal un known issues
--------------------------------------------------------------------------------------------------------------------------
    								Creating Objects
You can Create object inside class but, need to call objects method inside main/other methods only but you can use the objects varailble value at class level.
we can call private/ protected classes inside same class not to other classes
In the case of a static method, we don’t need to create an object to call the method. We can call the static method by using the class name 

Create objects
new           - Keyword obj = new Keyword();
newInstance() - NewInstanceMethod obj =(NewInstanceMethod) cls.newInstance();/ NewInstanceMethod obj = constructor.newInstance();
clone()       - CloneMethod obj2 = (CloneMethod) obj1.clone();
serialization - FileOutputStream fileOut = new FileOutputStream("/tmp/employee.ser");
factory method - Design Pattern

Here is given the 6 usage of java this keyword.

super() is added in each class default constructor automatically by compiler if there is no super() or this()

this can be used to refer current class instance variable. - this.rollno=rollno; 
this can be used to invoke current class method (implicitly) - this.m(); 
this() can be used to invoke current class constructor - this(5);  
this can be passed as an argument in the method call -  m(this);  
this can be passed as argument in the constructor call - B b=new B(this);  
this can be used to return the current class instance from the method - return this;  

INSTANCE initializer block {//some logic at class level }
it is invoked after super() and at runs at method level

When type of the object is determined at compiled time is known as STATIC binding. Dog d1=new Dog();  d1.eat();  
When type of the object is determined at run-time is known as DYNAMIC binding.  Animal a=new Dog();    a.eat();  

instanceof - boolean - if object is an instance of class or subclass or interface, only way to downcast(errors otherwise)

 A class cannot be private or protected except nested class

 default modifier is accessible only within package
 protected access modifier is accessible within package and outside the package but through inheritance only.
--------------------------------------------------------------------------------------------------------------------------
						Data Types
Primitive - due to this data types java is not 100% obj oriented, we use wrapper class
int, double, char, boolean, long, float, byte, short

Non Primitive 
Arrays and Strings - allows all primitive, like array of integers, string of boolean etc,

camelCase
PascalCase
snake_case
kebab-case

String pool (possible only because String is immutable in Java)
- new obj creates here, if same obj pointed to this existing memory else, if new obj, it will create new obj
s1= "hello";
s2= "hello";
will be pointed to same memory in the string pool, s1==s3;

s3= new String("hello"); will be created as new obj in diff string pool in heap memory  
--------------------------------------------------------------------------------------------------------------------------
						Wrapper Class
									
A Wrapper class is a class contains a primitive data types[toString(), int ti INTEGER vice versa]. They convert primitive data types into objects. When we create an object to a wrapper class, it contains a field and in this field, we can store a primitive data types. 

conversion of primitive data type into its corresponding wrapper class is known as AUTOBOXING
conversion of wrapper type into its corresponding primitive type is known as UNBOXING
Since Java 5, we don't use explicitly valueOf()/ intValue() for convertion
--------------------------------------------------------------------------------------------------------------------------
								Static vs Final(Keywords)

The static member can be accessed before the class object is created. It share among all the objects of a class. when program runs, before the main method, static method loads and prints if there is a sysout 

Final keyword is used to declare - 
a variable which cannot modified, 
a method which cannot be overridden and 
a class that can not be inherited
a paramter inside a method
but you can still change its state (using setter methods e.g) or using append functions. 

cant change value, can't method overload, can inherit but cant modify
can initialize blank final variable at only in constructor, likewise you can initialize in static block for static 
Final modifier is applicable for variable but not for objects.(static final void())
--------------------------------------------------------------------------------------------------------------------------

Final CLASS can't be inherited, final METHOD can't be overridden and final VARIABLE value can't be changed. 
Finally is used to place important code, it will be executed whether exception is handled or not. 
Finalize is used to perform clean up processing just before object is garbage collected.
-------------------------------------------------------------------------------------------------------------------------
								UpCasting
https://www.javatpoint.com/downcasting-with-instanceof-operator

If the reference variable of Parent class refers to the object of Child class, it is known as upcasting. 
class A{}  
class B extends A{
A a=new B();}//upcasting  

Upcasting is "casting a subtype to a supertype", upward to the inheritance tree. In general, we don't use upcasting unless if we want to write a code which deals only supertype.

DOWNCASTING is casting to a subtype, downward to the inheritance tree. Downcasting may fail if the actual object type is not the target object type. by throwing a ClassCastException.
instanceof - is  way[ if(a instanceof Dog3){    Dog3 d=(Dog3)a;//downcasting  ] to downcast(errors otherwise)
Dog4 d=(Dog4)a;//downcasting  
--------------------------------------------------------------------------------------------------------------------------
					OOP(object oriented programming)

programming based on the concept of "objects",instead of just functions and procedures!

-> Class/Object
-> Inheritance    
-> Encapsulation   
-> Polymorphism   
-> Abstraction     
-> Assosiation(relation b/n 2classes) - Aggregation(weak association, temporary) and Composition(Strong Association, lifetime) 
-> Aggreagation 1:1(assosiation HAS-A relation where methods survive without eachother) 
-> Composition(restrict form of aggregation, methods depend on each other, PART-OF relation, cannot exist without eachother)
--------------------------------------------------------------------------------------------------------------------------
									OBJECT CLASS
Object class is the parent class of all the classes in java by default. In other words, it is the topmost class of java
It provides some common behaviors to all the objects such as object to compared, cloned, notified etc.

public final Class getClass()	     returns the Class of the obj and also used to get the metadata of this class.
public int hashCode()	          returns the hashcode number for this object.
public boolean equals(Object obj)	compares the given object to this object.
protected Object clone()       	creates and returns the exact copy (clone) of this object.
public String toString()	          returns the string representation of this object.
public final void notify()	     wakes up single thread, waiting on this object
public final void notifyAll()  	wakes up all the threads, waiting on this object
public final void wait()           current thread to wait for the specified milliseconds
protected void finalize()     	is invoked by the garbage collector before object is being garbage collected
--------------------------------------------------------------------------------------------------------------------------
							         CLONE()
object cloning is a way to create exact copy of an object. 
The java.lang.Cloneable interface must be implemented by the class whose object clone we want to create. 
If we don't implement Cloneable interface, clone() method generates CloneNotSupportedException.
    protected Object clone() throws CloneNotSupportedException {
    			Student18 s1 = new Student 18(101,"amit"); 
    			Student18 s2 = (Student18)s1.clone();      } 

dis adv - To use the Object.clone() method, we have to changes in code, like implementing Cloneable interface, defining clone() method and handling CloneNotSupportedException, and finally, calling Object.clone() 

							  shallow and deep copy 
In shallow copy we create new objects that are exact copies of original object with reference address(i.e., memory address). 
In overridden clone method, if you are not cloning all the object types (not primitives), then you are making a shallow copy.
If you modify one object, the change will be reflected in the other object

In deep copy, it copies all fields, and makes copies of objects to which it refers(memory pointed)	
--------------------------------------------------------------------------------------------------------------------------
						Encapsulation (getter,setter)

"each object is private, inside a class. Other objects don’t have direct access but, they can access public functions(methods) but cannot change them". [get(),set(), seperate code, methods and communicate via method calling] 
 Java Bean class is the example of a fully encapsulated class.

It helps in binding methods and variables together. 
It provides data hiding. 
It helps in controlling the access using access modifiers.

ENCAPSULATION AND ABSTRACTION can help us in develop and maintain a huge codebase.
--------------------------------------------------------------------------------------------------------------------------
						Abstraction (only methods no logic)
A class which is declared with the abstract keyword is known as an abstract class 
A method which is declared as abstract and does not have implementation is known as an abstract method
Abstract class (abstract and non-abstract methods) but Interface only abstract methods

Applying abstraction means that each "object should only expose a high-level mechanism and hide internal implementations".
it is an natural extension of encapsulation.

EXAMPLE -> 
coffee machine makes lot of noises under the hood, you have to just put coffee and press a button without knowing how it works

							INTERFACE
interface in Java is a blueprint of a class, it has only static constants and abstract methods[empty body and fields are public, static and final]. A class that implements an interface must implement all the methods declared in the interface
Since Java 8, we can have default METHODS [default void msg(){}] and staic method[static int cube(int x){return x*x*x;}]
Since Java 9, we can have private methods in an interface

It's used to achieve abstraction and multiple inheritance and loose coupling.
Interface fields are public, static and final by default[public static final int n=8;], and the methods are public and abstract[public abstract void method(){}] takes care by compiler

a class extends another class, an interface extends another interface, but a class implements an interface.
multiple inheritance is not supported in the case of class because of ambiguity, in case of an interface no ambiguity because its implementation is provided by the implementation class

An interface which has no member is known as a marker or tagged interface, for example, Serializable, Cloneable, Remote, etc
--------------------------------------------------------------------------------------------------------------------------
						abstract class vs interface ?

Abstraction class and Interface both of them are used for abstraction(shows only useful features & hides the internal implementation)

An "ABSTRACT CLASS(uses extends) used to create functionality that child classes can implement or override". 

An INTERFACE(uses implements) "has definition or signature of functionality but, cannot implement it". 

A class can extend only one abstract class but,it can take advantage of multiple interfaces.
--------------------------------------------------------------------------------------------------------------------------
						  Inheritance (parent child) extends

Objects are often very similar while writing a code. They share common logic, But they’re not entirely the same!! 
by using inheritance, we can reuse the common logic and seperate unique logic into a separate class.
The "child class reuses all fields and methods of the parent class (the common part) and can implement its own" (unique part).

To reduce the complexity and simplify the language, multiple inheritance is not supported in java.

Inheritance should be used only if the relationship is-a is maintained throughout the lifetime of the objects involved; otherwise, aggregation is the best choice
--------------------------------------------------------------------------------------------------------------------------
							Polymorphism(over ride/load)

Ii is a way to use class exactly like its parent without any confusion with mixing types. But each child class have its own methods.
Parent class has bunch of methods. "child inherits parent class and implents it's own version of methods".

						Overloading - compile time polymorphism
Overloading occurs when two or more methods in one class have the SAME METHOD NAME but DIFFERENT parameters.
Type Promotion (int to long). Ambigity error if same parameters
Method overloading is performed within class.

								Overriding -Runtime Polymorphism- On Inheritance
Parent class reference points to the child class object then the call to the overridden method is determined at runtime, because during method call which method(parent class or child class) is to be executed is determined by the type of object, also called dynamic method dispatch
static method cannot be overridden
Runtime polymorphism can't be achieved by data members- int num=10; in parent class used not from child class int num=20;
If you don't override the parent method, objects refer to child class of same method name 
Before Java5, it was not possible to override any method by changing the return type. But now, since Java5, it is possible to override method by changing the return type if subclass overrides any method whose return type is Non-Primitive but it changes its return type to subclass type
--------------------------------------------------------------------------------------------------------------------------
									String
string is basically an object that represents sequence of char values. An array of characters works same as Java string
concat(), equals(), split(), length(), replace(), compareTo(), substring()
implements Serializable, Comparable and CharSequence interfaces
Java String is a powerful concept because everything is treated as a String if you submit any form in window based, web based or mobile application.

s.intern() - checks if string is available in Stringpool else creates new and returns

CharSequence interface is used to represent the sequence of characters. String(immutable), StringBuffer, StringBuilder(mutable) implement and these classes use to create strings in java

  String s=50+30+"Sachin"+40+40;  -> 80Sachin4040

String.join() method is available in Java version 8 and above->  String s = String.join("hello",s1,s2); -- s1hellos2
//StringTokenizer class allows you to break a String into tokens/ Strings [deprecated use split()]

StringBuffer class in Java is the same as String class except it is mutable. initial capacity is 16 to increse oldcapacity*2)+2
doesn't override the equals() method of Object class.
faster while performing concatenation operation then String and slower than StringBuilder
StringBuffer is synchronized, thread safe. It means two threads can't call the methods of StringBuffer simultaneously

StringBuilder is the most popular and fastet way to concatenate strings in Java
StringBuilder is non-synchronized ,not thread safe. It means two threads can call the methods of StringBuilder simultaneously.
StringBuilder is more efficient/faster than StringBuffer(introduced in Java 1.5)

Map <int, String> hm = new Hashmap<int, String>();
hm.getvalue(key);

Java String to Class object - Class.forName()
--------------------------------------------------------------------------------------------------------------------------
Data Structures

			ARRAY 
array is an object of a dynamically generated class. Java array inherits the Object class, and implements the Serializable as well as Cloneable interfaces. We can store primitive values or objects
arr.length;
+							-negatives
Storing 						size is fixed 
Random Access

If we clone single-dimensional array, it creates the deep copy of the Java array means, it will copy the actual value. 
if we clone multidimensional array, it creates the shallow copy of the Java array which means it copies the references.
Clone() is the fastest way to copy array.

--------------------------------------------------------------------------------------------------------------------------
                                           Collections

List store the ordered collection of objects. It can have DUPLICATE values. List interface is implemented by the classes ArrayList, LinkedList, Vector, and Stack.

ArrayList (best for storing, retrieving) uses a dynamic array to store the duplicate element of different data types. The ArrayList class maintains the insertion order and is non-synchronized. The elements stored in the ArrayList class can be randomly accessed.

EnsureCapacity() in ArrayList to resize the List with performance.
Remove integer value from arrayList, use ->   remove(Integer.valueOf(77)); removes 77 value not index!
ensureCapacity()	setLength()	trimToSize()
Capacity	Buffer capacity is set irrespective of length	Length (number of characters) is set. Buffer may be more than length	Extra buffer is deleted than required to store the characters
Iterator.hasnext();   iterator.next();//to get the values in the List


LinkedList(best for modification insert, delete) uses a double linked list internally to store the elements. It can store the duplicate elements. It maintains the insertion order and is not synchronized. In LinkedList, the manipulation is fast because no shifting is required.

Hashmap(best for seraching due to hashing) stores the data in Key(hashing and buckets), Value pairs. To access a value it must know its key. Hashing is a technique of converting a large String to small String that represents the same String. A shorter value helps in indexing and faster searches. 
In a HashMap the key is an object, that contains hashCode() and "equals(Object)" methods (to check already inserted or not)

1 null key and null values

					COLLLISION (only same indexes) different from replacing same value

distribute the values
Store in next bucket
Create a linked list at the index.

if you create (E,1) and update to (E,NULL) the hashmap wont allow GC to remove keys even if it has no reference 

Weakhashmap -works different and allow GC to collect unused objects

LinkedHashSet

if sync hashmap is existing why java 5 introduced concurrent hash map?
not thread safe, performance, due to lock every bucket while read/write 
read any threads but write lock on spe 


Set unordered set of elements which DOESNOT allow us to store the duplicate items. We can store at most one null value in Set. Set is implemented by HashSet, LinkedHashSet, and TreeSet.

Hashset uses a hash table for storage. Hashing is used to store the elements in the HashSet. It contains UNIQUE items.HashSet  uses HashMap internally.

Hashtable is synchronized. It is thread-safe and can be shared with many threads. doesn’t allow any null key or value.

Queue uses FIFO(First In First Out)

Stack used to store & delete LIFO(Last In First Out). push n pop methods.

flatMap() produces a stream of new values
map() it produces a single value

Vector uses a dynamic array to store the data elements. It is similar to ArrayList. However, it is synchronized and contains many methods that are not the part of Collection framework.

-------------------------------------------------------------------------------------------------------------------
						Comparator vs Comparable

Comparator interface compare(Object o1, Object o2) method need to be implemented that takes two Object argument, it should be implemented in such a way that it returns negative int if the first argument is less than the second one and returns zero if they are equal and positive int if the first argument is greater than the second one.

Comparable interface has compareTo(T obj) method which is used by sorting methods. We should override this method in such a way that it returns a negative integer, zero, or a positive integer if “this” object is less than, equal to, or greater than the object passed as an argument.	
==========================================================================================================================
							Serialization

Serialization is the process of "converting an object into a stream of bytes to store in a database", or a file. Its main purpose is to save the state of an object in order to be able to recreate it when needed. The reverse process is called deserialization.
											
						Serialize vs marshall
When you serialize an object, only the member data within that object is written to the byte stream; not the code that actually implements the object.

Marshalling is a process to transfer data between the RMI (Remote Method Invocation is an API for creating applications, for communicating b/n applications using two objects stub and skeleton). 

It's a process of converting the data or the objects into a byte-stream, and "unmarshalling" is the reverse process of converting the byte-stream beack to their original data or object using "serialization".
-------------------------------------------------------------------------------------------------------------------------
 						      TRY/ Catch
For each try block, there can be only 1 finally block.
finally block will not be executed if program exits by calling System.exit(); or by causing a fatal error that abort process
If an exception is not handled in the catch statement, before terminating the program, JVM executes the finally block
throw  used to throw an exception
throws used to declare exceptions

 			  					Exceptions

Checked exceptions(class that inherits Throwable class) are checked at COMPILE time. file not found, input io 
Unchecked exceptions(class that inherits RuntimeException) are checked at RUN time. arithematic, out of bounds, npe 
Error is irrecoverable. Some example are OutOfMemoryError, VirtualMachineError, AssertionError etc.

Throws(method) clause is used to declare an exception- public int division(int a, int b) throws ArithmeticException
Throw keyword is used to throw an exception explicitly  -> throw new ArithmeticException("Arithmetic Exception");

ConcurrentModificationException - modify an element, before finishing the iteration

If the size is int or long and the results overflow the range of value, the methods addExact(), subtractExact(), multiplyExact(), and toIntExact() throw an ArithmeticException
--------------------------------------------------------------------------------------------------------------------------
								REGEX
Regular Expression is an API to define a pattern for searching or manipulating strings

//1st way  
Pattern p = Pattern.compile(".s");// . represents(dot) single character  
Matcher m = p.matcher("as");  
boolean b = m.matches();  
  
//2nd way  
boolean bool = Pattern.compile(".s").matcher("as").matches();  
  
//3rd way  
boolean br = Pattern.matches(".s", "as");  


--------------------------------------------------------------------------------------------------------------------------
								THREAD
A thread in Java at any point of time exists in any one of the following states. A thread lies only in one of the shown states at any instant:

New
Runnable
Blocked
Waiting
Timed Waiting
Terminated

A multi-threaded program allocates a fixed amount of time to each individual thread. Each and every thread runs for a short while and then pauses and relinquishes the CPU to another thread, so that other threads can get a chance to run. When this happens, all such threads that are ready to run, waiting for the CPU and the currently running thread lies in runnable state. It is the responsibility of the thread scheduler to give the thread, time to run.

								Two ways to create a THREAD:

1.By EXTENDING Thread class (provides constructors and methods to create and perform operations on a thread.Thread class extends Object class and implements Runnable interface)
We create a class that extends the java.lang.Thread class. This class overrides the run() method available in the Thread class
EX->

class Multi extends Thread{  

public void run(){  
     System.out.println("thread is running...");  
}  

public static void main(String args[]){  
		Multi t1 = new Multi();  
		t1.start();  
 }  }

Output:thread is running
-   -   -  -   -   -   -   
2.By IMPLEMENTING Runnable interface (should be implemented by any class whose instances are intended to be executed by a thread. Runnable interface have only one method named run()
EX->

class Multi implements Runnable{  

public void run(){  
	System.out.println("thread is running...");  
}  
  
public static void main(String args[]){  
	Multi m1 = new Multi();  
	Thread t1 = new Thread(m1);  
	t1.start();  
 }  }  

Thread Class vs Runnable Interface 

If we extend the Thread class, our class cannot extend any other class because Java doesn’t support multiple inheritance. But, if we implement the Runnable interface, our class can still extend other base classes.
We can achieve basic functionality of a thread by extending Thread class because it provides some inbuilt methods like yield(), interrupt() etc. that are not available in Runnable interface.
Using runnable will give you an object that can be shared amongst multiple threads. 

Always recommendable logically calling Thread.start() to start a new thread
thread.start()-> create a new thread(t0) and calls thread.run()
thread.run()-> thread method 

join() method allows one thread to wait until another thread completes its execution

 invoking start() method on a thread that has already started throws a IllegalThreadStateException because the thread is already in RUNNABLE state.

Thread Pool

samsung care + 18778411138
--------------------------------------------------------------------------------------------------------------------------
						Threadsafe

A class is thread-safe when it continues to "behaves/ executes correctly when accessed/executed from multiple threads at same time" 
all the basic collection classes - ArrayList, LinkedList, HashMap, HashSet, TreeMap, TreeSet, etc - all are not synchronized
In fact, all collection classes (except Vector and Hashtable) in the java.util package are not thread-safe

how to make thread safe 
-> Making object final
-> Making the object private - maintaining the same state for the object by returning at the same place
-> Synchronizing the objects
-> Concurrent Collections - dividing the data into segments/process, multiple threads can access the multiple segments at the same time.
--------------------------------------------------------------------------------------------------------------------------
							   Immutable(for OBJECTs, its Thread safe) 

			The "object’s value can’t be changed, but you can change its reference" to another one.
immutability applicable for an object, classes(if final, no setters, private fields) but not for variables.
Advantages of immutable?
  It decreases the overhead by garbage collection and it protect from code corrupting. 
We should prefer Classes should be immutable unless there's a very good reason to make them mutable or try to limit its mutability as much as possible.

All the datatypes are mutable except String(objects are cached in the String pool and accessed by multiple clients, for security and synchronization. stringbuilder to mute, safe for multithreading)
--------------------------------------------------------------------------------------------------------------------------
JAVA - SOLID RULES
DB  - ACID Properties													
								ACID Rules

Maintain consistency in a database, before and after transaction, we follow - ACID properties

Atomicity(A) - By this, we mean that either the entire transaction takes place at once or doesn’t happen at all. There is no midway i.e. transactions do not occur partially. Each transaction is considered as one unit and either runs to completion or is not executed at all. Atomicity is also known as the ‘All or nothing rule’.
It involves following two operations.
—Abort: If a transaction aborts, changes made to database are not visible.
—Commit: If a transaction commits, changes made are visible.

Consistency(C) − This represents the consistency of the referential integrity of the database, unique primary keys in tables, etc.

Isolation(I) − There may be many transaction processing with the same data set at the same time. Each transaction should be isolated from others to prevent data corruption.

Durability (D) − Once a transaction has completed, the results of this transaction have to be made permanent and cannot be erased from the database due to system failure.
--------------------------------------------------------------------------------------------------------------------------
  							SOLID rules while writing a program

Single Responsibility (class should have only one responsibility. Further, it should only have one reason to change)

Open/Closed (Open for Extension, Closed for Modification)

Liskov Substitution (if class A is subtype of class B,then we should replace B with A without creating any disturbances)

Interface Segregation (large interfaces r split into smaller ones. Classes r concerned about methods that interest to them)

Dependency Inversion (decoupling high-level modules depending on low-level modules. Now both will depend on abstractions)
--------------------------------------------------------------------------------------------------------------------------	
							Garbage collection

Mark and sweep technique - 
cycle 1 -marks used obj(increaase the age) and unused obj
cycle 2 -sweeps the unused obj


We cannot force garbage collection. It will only trigger if JVM thinks it needs a garbage collection based on Java heap size. other threads in the application have to be stopped to allow the garbage collector thread to effectively do its work. 
parent object is set to null
cleans Cyclic dependencies without any live external reference
finalize() Finalize is used to perform clean up processing just before object is garbage collected.

When Garbage Collector calls finalize() method on an object, it ignores all the exceptions raised in the method and program will terminate normally.

We know that finalize() method is called by Garbage Collector on an object before destroying it. But here, the trick is that the str is String class object, not the Test class. Therefore, finalize() method of String class(if overridden in String class) is called on str. If a class doesn’t override finalize method, then by default Object class finalize() method is called.

If finalize() method is already called for one object, Garbage Collector will destroy the same object if created again without calling finalize() method again
--------------------------------------------------------------------------------------------------------------------------
										STACK  VS HEAP MEMORY

Heap - Young generation (hidden space- all the obj store here, if it's full minor GC called and marked unused obj and 
used obj moved to survivor 0
(hidden space, survivor 0 and survivor 1(from survivor0 and hidden space if used))

old gen(moved from young if used often), 
pom gen(moved here if old is full and major GC is called if pom gen is full) 

stack memory is used to store local variables and function, Variables stored in stacks are only visible to the owner.
heap memory is used to store objects in Java, visible to all threads.

Stack memory is used only by one thread of execution.	    Heap memory is used by all the parts of the application.
Stack memory can’t be accessed by other threads.	        Objects stored in the heap are globally accessible.
Fllows LIFO manner to free memory.	                        Memory management is based on the generation associated with each    															object.
Exists until the end of execution of the thread.	        Heap memory lives from the start till the end of application 																	execution.
Stack memory only contains local primitive and reference 
variables to objects in heap space.	                         Whenever an object is created, it’s always stored in the Heap space
--------------------------------------------------------------------------------------------------------------------------
                              ****************JAVA 8 FEAUTURES**************

Streams(used for Operations on Collections)
intermediate(can modify after this like filter, map) or terminal methods(cant manipulate after like collect)

"FUNCTIONAL INTERFACES"  earlier there are no restrictions for abstract methods in interface, from java 8, they have restricted to have one abstract class and mulitple default static/default methods. used for reference to lamba expression
(EX-> eval(list, n-> n > 3); //printing no greater than 3). A functional interface is an interface that contains only one abstract method(one functionality to exhibit). EX -  Runnable, ActionListener, Comparable

LAMBDA EXPRESSIONS(Optionals, has body and parameter list)EX- MathOperation multiplication = (int a, int b) -> { return a * b; } )
->used to represent the instance of a functional interface

"METHOD REFERENCES" which help to point to methods by their names. 
 symbol - two colons :: (ex -> names.forEach(System.out::println)for printing all names in different lines)




NEW (simple)date-time API- using java.time for handling timezones, poor design like 0/1/1900, thread safe .

"Parallel Opearions" (sorting, filtering and mapping)

"MUTABILITY" java 8 feauturs are implemented in an immutable fashion 

"DEFAULT METHODS" (List/Collection interface can have a default implementation of FOREACH method, 
but, the class implementing these interfaces need not implement the same.)

"OPTIONAL" has not-null objects, handle values as ‘available’ or ‘not available’ instead of checking null values!
EX-> static <T> Optional<T> of(T value) -> it returns an Optional with the specified present non-null value.

"NASHORN" (we use jjs tool, to execute javascript codes at console), calling js from java using scriptEngineManager
EX -> jjs> print("Hello, World!")												
-------------------------------------------------------------------------------------------------------------------------
								Enterprise JavaBeans (EJB)
Has the business logic of the model.
EJB systems are written in Java, they are platform independent. Being object oriented(POJO), they can implement into existed systems probably with recompiling and configuration.
An EJB server provides functions like threading, concurrency, security and memory management. 

A transaction can be managed by either the container(default) or the bean.
In Container-managed transactions (CMT), "EJB" takes care of starting and commiting the transactions whenever needed. All session and message-driven beans may use CMT.

In Bean-managed transactions (BMT), the "bean-provider" take care of the transactions(start and commit). Session and message-driven beans may use BMT.

-------------------------------------------------------------------------------------------------------------------------
											Spring Bean Scope

The core of spring framework is it’s bean factory and mechanism to create and manage beans inside the Spring container.
@Bean
configuring type of bean->
@Scope(value="singleton/ prototype/ session etc") 
XML file <bean id="demoBean" class="com.howtodoinjava.application.web.DemoBean" scope="session" />

The beans in spring container can be created in five scopes i.e. 

1.SINGLETON (default) – Creates only one bean instance for the spring container. While using we have to check for shared instances  to avoid data inconsistency issues. [ default scope of bean ]

2.PROTOTYPE –  Created by request from spring container.

3.REQUEST(web applications) – Similar to prototype it's created by HTTP request.

4.SESSION – A new bean will be created for each HTTP session by the container.

5.GLOBAL SESSION SCOPE– Creates global session beans for Portlet applications.

We can define bean scope in -> 
-------------------------------------------------------------------------------------------------------------------------
								Springboot:

extension of the Spring framework which removes the boilerplate configurations to set up Spring application.
starter dependencies
default server
Automatic config whenever needed(by looking at the dependencies, properties, and beans). If we want to do it manually it goes away

basic dependencies to start spring is "springbootstarterweb"
All other dependencies are added automatically during build time

Spring Boot uses Hibernate as the default JPA implementation.
spring.jpa.hibernate.ddl-auto is used for database initialization.

@SpringBootApplication == @ComponentScan + @Configuration + @EnableAutoConfiguration//entry point

how can we use other server in springboot by avoiding default tomcat server?
Spring Boot web starters use Tomcat as the default embedded servlet container.

				                        Dependency injection(DI)
Dependency Injection is the process where Spring framework search for the beans and identifies the dependencies, and creates bean instances by autowiring. 
Java based annotation, XML based annotation, annotation based 
It helps in removing hardcode by flexibility of changing the code at compiling or run-time.
n OOP, object reference plays a key role. DI provides it and we don't even need not to manage at application level. 
Spring and Google Guice are best examples for dependency Injection.
uses setter inj or field injection

									Inversion of Control (IOC). 
									
The control of creating a bean is taken from user and hand over to spring/container which is new obj creating. DI due to IOC  
In Spring(Loose Coupling) , we use @Autowired annotation over the dependency class then Spring takes the control of creating the instance and injecting the dependencies.
-> Find Beans  -> Identify their dependencies and wire the dependencies  -> Manage Lifecycle of the Bean (create,process, destruction)

										Application Context
Is an advanced version of IOC Container provides all the functionalities of Bean Factory like AOP, Internationalization capabilities, web application context (request, session, etc).
Created by using -> ClassPathXmlApplicationContext(XML Files) -> @Configuration

The Spring documentation recommends using constructor-based injection for mandatory dependencies, and setter-based injection for optional ones.


Starters - in pom.xml dependencies
predefined Endpoints - logs, env, disk space, health, et cetera
custom configurations - on bean, on class, on properties
Spring Actuators - custom endpoints to get staus of app


							WORKING
from the run method, the main application context started
searches for the classes annotated with @Configuration
stores those beans in JVM- IOC container
automatically configures the dispatcher servlet (for spring, autoconfig in spring boot by spring-boot-starter)
registers the default handler mappings, messageConverts, and all other basic things.


			POI        for excel
spring-boot-maven      -plugin, to package a web application as an executable JAR
spring-boot-starter: core starter, including auto-configuration support, logging, and YAML
spring-boot-starter-aop: starter for aspect-oriented programming with Spring AOP and AspectJ
spring-boot-starter-data-jpa: starter for using Spring Data JPA with Hibernate
spring-boot-starter-security: starter for using Spring Security
spring-boot-starter-test: starter for testing Spring Boot applications
spring-boot-starter-web: starter for building web, including RESTful, applications using Spring MVC
======================================================================================================================
										    @nnotations
https://springframework.guru/spring-framework-annotations/

@SpringBootApplication == @ComponentScan + @Configuration + @EnableAutoConfiguration//entry point
@ComponentScan(used with configuration) is also used to specify base packages using basePackageClasses 
@Configuration has methods to instantiate and configure dependencies.
@EnableAutoConfiguration is used for auto-configuring beans present in the classpath

@RestController is a convenience annotation that combines @Controller(every method returns a object instead of a view) and @ResponseBody(sends HTML as response) 
@Controller to indicate the class is a Spring controller

@Autowiring(DI injection) injects the object dependency implicitly by uses setter inj, constructor i or field injection.
@Entity is used to mark the class as a persistent Java class in DB
@RequestMapping - it routes the path
@Value to inject values from a property file into a bean’s attribute
@Component indicate a Spring component to component-scan add into the application context- specified beans creation

@Qualifier more control of the dependency injection the specific service 
@Column annotation is used to define the properties of the column that will be mapped to the annotated field
@Requiered On bean setter method to populated at configuration time without BeanInitializer exception.
@Lazy bean will be created and initialized only when it is first requested

@Repository tells Spring to bootstrap about repository during component scan.
@Bean works with @Configuration to create Spring beans.

@Get,Put, Post, Delete Mapping annotations are for mapping HTTP CRUD Operations.

@MappedSuperclass in hibernate supports entities to keep basic properties in a super class. The super class annotated by @MappedSuperclass will not behave as independent entity. It will not be associated with any database table. If we want to change the column name different from super class, we need to use @AttributeOverride.
@GetMapping("/notes") annotation is a short form of @RequestMapping(value="/notes", method=RequestMethod.GET)

@ConditionalOnMissingBean 
======================================================================================================================
 												Spring(core, Spring MVC, persistence, Spring Security)
It configures different modules like
Spring JDBC    
Spring MVC   
Spring AOP    
Spring ORM 
Spring Test         

 it provides support to various frameworks such as Struts, Hibernate, EJB, etc
 basic dependencies to start spring is "springweb" and "springwebmvc". All other dependencies are added automatically during build time.
--------------------------------------------------------------------------------------------------------------------------
						 convert JSON to XML or XML to JSON?
first convert from json,xml -> string, 
convert line break -> create object-> convert into xml, json 
Using the JsonConvert class
// XmlDocument doc = JsonConvert.DeserializeXmlNode(json);

--------------------------------------------------------------------------------------------------------------------------
								Jackson API
Jackson is a very popular and efficient java based library "to serialize or map java objects to JSON and vice versa".
achived in 3 ways-
-> Data Binding* (using annotations) [object - LinkedHashMap<String,Object> , array - ArrayList<Object> ,string - String]
-> Tree Model (tree representation of JSON using objectmapper)
-> Streaming API(JsonParser reads the data and JsonGenerator writes the data)		

									   ObjectMapper
ObjectMapper is the main class of Jackson library. It provides functionality for reading and writing JSON from POJOs or JSON Tree Model (JsonNode). It supports polymorphism and Object identity. It act as a factory for more advanced ObjectReader and ObjectWriter classes.
--------------------------------------------------------------------------------------------------------------------------
																						JSON
JSON (JavaScript Object Notation) is a text-based format shows structured data based on JavaScript object. 
It's used for transmitting data in web applications ie., between a server and web application.

To convert a Java object into JSON, the we use: -> GSON & JACKSON API
1. Add jar files of Jackson
2. Create a POJO(which convert into JSON)
3. Create a Java class (Convert the object into JSON using ObjectMapper class of JacksonAPI)
4. Execute. 
performing operations.
-------------------------------------------------------------------------------------------------------------------
 																							API

API is known as the Application Programming Interface and is offered by both the client and the server. In the client world, this is offered by the browser whereas in the server world it’s what is provided by the web service which can either be SOAP or REST.
-------------------------------------------------------------------------------------------------------------------------
 																					Webservice
 application to application communication(request, response)
 platform independent
 communication over the network

Add these concepts in the RESUME
                                            	 REST API

communication between client and server. Services are using URI (Unified Resource Identifier) using HTTP protocol.
URI is similar to URL of a webpage, if you want to call a webservice, you can use a URI and call the service using HTTP request.
No complex envelopes and protocols(unlike in soap), services work with Resources instead of operations.
REST has an architectural style which makes it processing free and flexible.
REST is faster compared to SOAP.
XML, JSON, HTML

HTTP METHODS - GET PUT POST DELETE TRACE OPTIONS(returns info about API (methods/content type), HEAD (return info about resource (version/length/type)
Idempotent(same results) are PUT GET DELETE HEAD
Java strictfp keyword ensures that you will get the same result on every platform if you perform operations

												SOAP
SOAP is an older web server technology with a complex definition for the messages that are sent back and forth. SOAP allows only XML data format. These messages are so called "Envelopes"(head, body) with additional information.
identify the Service and the Operations like GetCustomer, SaveCustomer(), UpdateCustomer()
because the operations are named by the developers. So anyone can name the operations differently. Because of this, the consumer / client needs to know the service contract completely if they need to work with that service. Also, they need to know which operation is doing what kind of activity.

Path Variable (identifying resource) and Query Parameter(filtering items)

http://www.google.com/hi/there?qs1=you&qs2=tube

query params
{
  qs1: 'you',
  qs2: 'tube'
}

req params
{
  param1: 'there'
}

SOAP stands for Simple Object Access Protocol whereas REST stands for Representational State Transfer.
SOAP is a protocol whereas REST is an architectural pattern.
SOAP uses service interfaces to expose its functionality to client applications while REST uses Uniform Service locators to access to the components on the hardware device.
SOAP needs more bandwidth for its usage whereas REST doesn’t need much bandwidth.
Comparing SOAP vs REST API, SOAP only works with XML formats whereas REST work with plain text, XML, HTML and JSON.
SOAP cannot make use of REST whereas REST can make use of SOAP.

--------------------------------------------------------------------------------------------------------------------------
			JWT (JSON web token)
1.API authorizing
2.data transfer[having all the details]

api's are secured with oauth2.0
access token and refresh token(response)
jwt.io
gmail oauth flow with java

https://anil-pace.medium.com/json-web-tokens-vs-oauth-2-0-85dd0b32057d

																	OAUTH
												
Access granting protocol. Data access without sharing username and passwords for every application.
Federated Authentication(App 2 App)
Delegated Authentication(App 2 other app's selected access)

									Spring security   
authentication, authorization Java apps
--------------------------------------------------------------------------------------------------------------------------
								what is restless and resfull services?

I had to smile when you mentioned “restless” but I understand what you mean. Not many people talk about services being restless. They generally call them SOAP or just services. Restless is basically any service that doesn’t follow the REST protocol
The main difference ins basically that REST is meant to be used with the HTTP protocols and thus basically uses web servers for the server side. Other services can use HTTP but can also use other transport layers instead. (SOAP can use SMTP, for example, which is an email protocol!)

										Java Message Service
JMS stands for Java Message Service. JMS is a standard that defines how you can access enterprise messaging systems from Java programs. 
JMS implemented by messaging service providers like IBM MQ(message queueing) to allow JMS client applications to access the provider’s messaging service
MQ is communication b/n service request and response
-------------------------------------------------------------------------------------------------------------------------
																						CORS
Cross-origin resource sharing (CORS) is a W3C specification implemented by most browsers that allows you to specify in a flexible way what kind of cross domain requests are authorized, instead of using less powerful hacks like IFrame or JSONP.
open access across domain-boundaries.
instruct browser to allow only certain HTTP methods (GET/PUT/POST/DELETE etc) on domain URLs.
-------------------------------------------------------------------------------------------------------------------------
																			Persistant Class

Java classes whose objects or instances are stored in database tables are called persistent classes in Hibernate. 
Hibernate works best if these classes follow Plain Old Java Object (POJO) programming model.

The concept of Hibernate is to take the values from Java class attributes and persist them into a database table. A mapping document helps Hibernate in determining how to pull the values from the classes and map them with table and associated fields.
All Java classes that will be persisted need a default constructor.

All classes should contain an ID in order to allow easy identification of your objects within Hibernate and the database. This property maps to the primary key column of a database table.

All attributes that will be persisted should be declared private and have getXXX and setXXX methods defined in the JavaBean style.

A central feature of Hibernate, proxies, depends upon the persistent class being either non-final, or the implementation of an interface that declares all public methods.

All classes that do not extend or implement some specialized classes and interfaces required by the EJB framework.

The POJO name is used to emphasize that a given object is an ordinary Java Object, not a special object, and in particular not an Enterprise JavaBean.
--------------------------------------------------------------------------------------------------------------------------
																			Hibernate

Spring Boot uses Hibernate(artist) as the default JPA(art) implementation.
spring.jpa.hibernate.ddl-auto is used for database initialization.
If you change the name or type of a field, or add another field to the model, then all these changes will be reflected in the mapped table as well.
---------------------------------------------------------------------------------------------------------------

Please explain the difference between an inner join and an outer join?
		Inner Join returns common in two tables(X intersection Y).
		
Outer Join has -> left outer join, right outer join and full outer join.  
		   Left Outer Join gives rows in A and common rows in B 
		   Right Outer Join gives rows in B and common rows in A
		   Full outer Join returns all rows in A and B (A union B).
--------------------------------------------------------------------------------------------------------------------------
Caching (caffeine/ redis)

Server cache
DB Cache
Browser Cache


lazy Loading(check cahce, if not present write into cache and return from datasource)
Read through(if data not in cahce, save into cahce from datasource and then return from Cache)
Write through (Write everything into cache and then save into db)
Write behind()
--------------------------------------------------------------------------------------------------------------------------
												
DB link - > https://bytescout.com/blog/20-important-sql-queries.html#4

												ODBC(open db connection)

With ODBC, we can "access data from any application, regardless of any DBMS" by inserting a middle layer "DATABASE DRIVER" between an application and the DBMS. 
DATABASE DRIVER translate the application's data queries into commands that DBMS understands.The application must be capable of issuing ODBC commands and the DBMS must be capable of responding to them.

--------------------------------------------------------------------------------------------------------------------------
											JDBC(Java Database Connectivity)

JDBC "allows Java programs to interact with any SQL based database" and execute SQL statements. It has a single database application that run on different platforms which interacts with different DBMSs.
JDBC is similar to ODBC, but is designed specifically for Java programs, whereas ODBC is language-independent.
					difference between SQL (such as SQL Server) and NoSQL (such as Mongo DB)?
	
MySQL(RDBMS) database can replicate across multiple nodes. We use MySQL for multiple row transactions and applications which run on legacy systems
MongoDB(distributed) is a good choice for databases having no specific schema definitions or if it keeps changing like mobile apps & real-time analytics.
The main difference is the way of storing the data(table-based VS key-value pair, document or graph).
We can scale in load on single server(MySQL) on other hand we can add servers(NoSQL).
--------------------------------------------------------------------------------------------------------------------------
								One to many relation
Consider the following example. Book table (pk_book_id, title, ISBN) is associated with Author (pk_author_id, author_name, phone_no, fk_book_id). One book can have many authors. This relationship can be implemented by using (PK_Author_Id as Primary Key) and (Fk_Author_Id as Foreign Key).
--------------------------------------------------------------------------------------------------------------------------
													Save vs Persist
save() generates a new identifier and INSERT record into database while saveOrUpdate can either INSERT or UPDATE based upon existence of record.
persist returns void.
Save returns Serializable object.  

										Stored Procedures
Store and call later

Delimiter// - say stmnt end
CREATE PROCEDURE pet()
BEGIN
		logic(commands)
END //
Delimiter;

SET @variable = 2013;   // set value
SELECT @variable := "avinash"; //return value(:= means assigning)
PRIMARY KEY
AUTO_INCRMENT
==========================================================================================================================
												JPA(Java Persistance API)

JPA, makes life easy for interaction with database instances. 
It is a collection of classes and methods used to store data in database.
It creates a mapping file(ORM.xml) between object models (Java program) and relational models (database program).
It stores business entities(POJO) as entities and manage the entities with relationships(1-1, 1-many, Many-1).
JPA INTERFACES -> Entity, EntityManaager, EntityManagerFactory, Persistance, Query

(Eager fetch)Fetching the whole record using Primary Key
(lazy fetch)fetches the record for the first time and stores it in cache memory for furthur use. Performance wise, lazy fetch is preferable.
-------------------------------------------------------------------------------------------------------------------------
													SWAGGER

documenting of endpoints- all possibilities
Conusumer will have all the information needed
springfox
=======================================================================================================================
										
Monolithic VS SOA VS MicroService

										Microservices
Microservices can adapt easily to other frameworks or technologies.
Failure of a single process does not affect the entire system.
Provides support to big enterprises as well as small teams.
Can be deployed independently and in relatively less time.

Disadvantage of DEVOPS - everything is individual

Note: App dynamics is tool provided on service instance and monitors how many end points are hit per sec.
How many transactions per sec. If transactions are going beyond certain threshold value we are going to advice go for another node.
=======================================================================================================================
										Design pattern(aka dp) 

Design pattern(aka dp) used to get a solution for the problem while developing a software(as a software developer view). 
It shows the relationships and interactions between classes or objects also speed up the development. It’s not mandatory to use dp always in your project they are meant only for solving problems. 
Whenever there is a need, you have to implement the suitable pattern to avoid such problems in future. 
To find out which pattern to use, you should have a clear picture about it and it’s purpose.

MAIN Categories -
Creational -> create objects while hiding the creation logic
Structural -> What does a class contain? and relationships of a class with other. Is it inheritance or composition?
Behaviuoral -> communication between objects

Most used
Singleton -> Create only one object, and make the constructor private so that it cannot be used
Strategy -> Keep mulitple algoriths, DS under one abstract and while runtime choose best one
Factory -> Create object of class and both classes will be tightly coupled
Adapter -> Changing from one state to another- Marshall/Unmarshalling
State -> Changing the state from one place to another (Overriding)
Builder/Composite -> Creating an object by assosiating with multiple objects
Observer -> If the object's state changes, it impacts/notifies the other places where it used
--------------------------------------------------------------------------------------------------------------------------
																		Message Queue
MQ queues can be thought of as conduits to transport messages between Queue Managers. There are four different types of MQ queues and one related object. The four different types of queues are: Local Queue (QL), Remote Queue (QR), Transmission Queue (TQ), and Dead Letter Queue, and the related object is a Channel (CH)
--------------------------------------------------------------------------------------------------------------------------
																					Splunk
Use Splunk for Log Analysis
monitoring, searching, analyzing, visualizing and acting on voluminous streams of real-time machine data
--------------------------------------------------------------------------------------------------------------------------
																			Dockers

Docker is a basic tool, like (git VCS) for app's operating system. It uses btrfs (a copy-on-write filesystem) to keep track of filesystem. has a central repository of disk images (upload and download images) that allow you to easily run different operating systems.
The whole idea of Docker is for developers to easily develop applications, ship them into containers which can then be deployed anywhere.
In the case of Linux and non-Hyper-V containers, the Host OS shares its kernel with running Docker containers. For Hyper-V each container has its own Hyper-V kernel
Docker images can be pushed to a repository and can be pulled down to any other host to run containers from that image.
when we want to distribute/collaborate on your app's operating system with a team We use it 
Docker is basically a container engine which uses the Linux Kernel features like namespaces and control groups to create containers on top of an operating system and automates application deployment on the container 
Docker has an workflow for moving application from developers laptop, test environment to production

Dockers have docker containers, images, registries, docker client.
image is a file used to execute code in a Docker container. An image is built from the instructions
--------------------------------------------------------------------------------------------------------------------------
														  docker vs  Virtual Machine
Docker is container based technology, Virtual Machine on the other hand, is not!
In Docker, the containers share the host OS kernel, VM environment shares hardware resource from the host.
With a container environment, multiple workloads can run with single OS.In Virtual Machine environment, each workload needs a complete OS.
=====================================================================================================================
							Behavior Driven Development(simply BDD)

Behavior Driven Development(simply BDD) is a customer-focused process. 
It is based on the understanding of the system or module behavior but in the terms of business/client.
In BDD, we share our expected behaviors across all members of the team.
understand these needs from the start and testing external business behaviors 
that the entire team cares about—that is a great way to ensure a quality project.
=======================================================================================================================
						    GIT COMMANDS
								create a new repository on the command line
git init
git add README.md
git commit -m "first commit" -> commenting
git remote add origin https://github.com/avinashseven/ide.git -> URL
git push -u origin master

	 					push an existing repository from the command line
git remote add origin https://github.com/avinashseven/ide.git -> URL
git push -u origin master

							Differenciation in two repo's ->
git remote add -f b path/to/repo_b.git
git remote update
git diff master remotes/b/master
git remote rm b
-------------------------------------------------------------------------------------------------------------------
													Applets
Applet is a Java program that can be embedded into a web page. It runs inside the web browser and works at client side. Applet is embedded into a HTML page by using the APPLET or OBJECT tag and hosted on a web server.
"Applets are used to make the web site more dynamic and entertaining"
When an applet begins, the methods are called, in this sequence:
1. init( )
2. start( )
3. paint( )
destroy()(remove completely from memory, only after free up any resources attached to the applet)
--------------------------------------------------------------------------------------------------------------------------
											Servlet(pacckage ->javax.servlet)

Java Servlet is a "way to create dynamic web pages".
Small program which handles complex requests from a web or application server.
once started, it stays in memory and used for multiple requests.
CYCLE->
Clients send the request to the web server -> Web server receives the request -> Web server passes the request to the corresponding servlet -> servlet processes the request and generate the response(output) -> servlet send the response back to the web server -> Web server sends the response back to the client and he can see it on screen.
--------------------------------------------------------------------------------------------------------------------------
										      						 JSP

Java Server Page (JSP) is a server-side technology(extension to the Java servlet)
separates the logic from the actual design and display of the webpage.
JSP is translated into Java servlet before running, and processing HTTP requests to generate response like servlets.
JSPs are fully interoperable with servlets. You can include output from a servlet or forward the output to a servlet, and a servlet can include output from a JSP or forward output to a JSP.
==========================================================================================================================
		 															Request Dispatcher
									
Request Dispatcher is an interface defines an object which can dispatch the request to any resources on the server(it may be html, servlet or jsp).
Two Types -> forward method(response from another servlet)
-----------> Include method(response from same servlet but it uses the response of another connected servlet)

-------------------------------------------------------------------------------------------------------------------

CLIENT is an application that runs on a personal computer or workstation which depends on a server for 
-------------------------------------------------------------------------------------------------------------------
									HTML(HyperText Markup Language)

HTML is used to create documents on the World Wide Web.
It defines the structure and layout of a Web document by using variety of tags and attributes
There are hundreds of tags used to format and layout the information on a Web page.
major changes in HTML5 is the addressing Web applications, functions for embedding graphics, audio, video, and interactive documents.
 new tags like < article >, <nav>, <source>, 
 ---------------------------------------------------------------------------------------------------------------
												Staging

A staging(pre-production) environment is a nearly exact replica of a production environment for software testing. 
Staging environments are made to test codes, builds, and updates to ensure quality under a production-like environment before application deployment
Smoke tests check for service functionalities
User acceptance testing (UAT) are performed from the end user point of view.


=========================================================================================================================
									PROD Support

Tools:
	Dynatrace- monitoring tool- used to monitor proceess time, failure, we can create dashboards, alerts, can be used to check if network latency
	SumoLogic-
	Kibana -
	Tableau -
	Openshift -

	track the data, logs, time - 
	user will notify/ we need to keep track
	observing the patterns
	business analysis
	other teams change and releases
	backtracking
	Server patching/ restarting
	TLS timeouts
	Firewall rule changes
	Alerts, Notifying
	Planned Outages

business observations
innovation US
layman language

--------------------------------------------------------------------------------------------------------------------------
1×× Informational
100 continues       			101 Switching protocols        102 Processing

2×× Success
200 OK       201 Created     202 Accepted     203 Non-authoritative Information    204 No Content
205 Reset Content     206 Partial Content    207 Multi-Status       208 Already Reported         226 IM Used

3×× Redirection
300 Multiple Choices     301 Moved Permanently     302 Found      303 See Other       304 Not Modified
305 Use Proxy          307 Temporary Redirect     308 Permanent Redirect

4×× Client Error
400 Bad Request      401 Unauthorized         402 Payment Required      403 Forbidden
404 Not Found        405 Method Not Allowed   406 Not Acceptable        407 Proxy Authentication Required
408 Request Timeout  409 Conflict             410 Gone                  411 Length Required
412 Precondition Failed   413 Payload Too Large
414 Request-URI Too Long    415 Unsupported Media Type
416 Requested Range Not Satisfiable   417 Expectation Failed
418 I’m a teapot   421 Misdirected Request
422 Unprocessable Entity   423 Locked
424 Failed Dependency   426 Upgrade Required
428 Precondition Required  429 Too Many Requests
431 Request Header Fields Too Large  444 Connection Closed Without Response
451 Unavailable For Legal Reasons   499 Client Closed Request

5×× Server Error
500 Internal Server Error  501 Not Implemented        502 Bad Gateway    503 Service Unavailable
504 Gateway Timeout           505 HTTP Version Not Supported     506 Variant Also Negotiates
507 Insufficient Storage             508 Loop Detected        510 Not Extended
511 Network Authentication Required      599 Network Connect Timeout Error
